__ max of two values
def :max [
  cut drop swap popl     __ take the left item
    . [! <=]             __ filter with <=
    | drop popl dup      __ [b a b] | [a b a b]
    . dup pushr pushr [] __ [a b a b]
]

__ min of two values
[[] pushr pushr dup . dup popl drop | [> !] . popl swap drop cut] :min def

__ if then else
[[] pushr pushr swap pushl [0 == !] [drop drop] | . popl swap drop cut] :ifte def

__ take rightmost value from quote
[popl swap drop] :head def

__ apply a quote to a single input yielding a single output
[pushr popl swap drop] :ap11 def

__ apply a quote to two inputs yielding a single output
[pushr pushr popl swap drop] :ap21 def

__ apply a quote to a single input yielding two outputs
[pushr popl swap popl swap drop swap] :ap12 def

__ apply a quote underneath the top, 1 -> 1
[swap pushl pushr popl swap popl swap drop swap] :dip11 def

__ apply a quote underneath the top, 1 -> 2
[swap pushl pushr popl swap pushr [swap] . popl swap popl swap popl swap drop] :dip12 def

__ apply a quote underneath the top, 2 -> 1
[swap pushl pushr pushr popl swap popl swap drop swap] :dip21 def

__ rotate top 3
[[] swap pushl swap pushl pushr popl swap popl swap popl swap drop] :rot def

____todo
=or swap [dup 0 != !] ap11 swap | cut
=and 1 rot rot 0 != ! 0 != ! 0 | cut
@fix, select disappears: =and 1 rot rot 0 != ! 0 != ! 0 or

@alternate: =ifte2 rot [swap drop 0 != !] [0 == !] | pushr pushr pushr popl swap drop cut

@ recursive call test
=mod5 [dup 5 < !] [dup 5 >= swap 5- mod5 swap !] | pushr popl cut swap drop
@fix: =fib dup 2 < [1 swap drop] [dup 1- fib swap 2- fib +] ifte pushr head
@fix: =loop dup 1 > [1- loop] [] ifte pushr head

@fix: =fact dup 1 > [dup 1- fact *] [] ifte pushr head

=top0 [popl] [0] | pushr popl swap drop cut
todo____