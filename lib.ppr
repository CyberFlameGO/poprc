module lib:

imports:
  module num
  module list
  module stack
  module control


module num:

__ max of two values
max: [] pushl pushl dup . dup popr drop | [<= !] . popr swap drop

__ min of two values
min: [] pushl pushl dup . dup popr drop | [> !] . popr swap drop


module list:

__ take rightmost value from quote
head: popr swap drop


module stack:

pull: popr swap
pull2: pull pull
pull3: pull2 pull
pull4: pull3 pull
pull5: pull4 pull

nip: swap drop
tuck: [] ap20 dup . pull3 drop
over: swap tuck

rotl: swap2
rotr: swap2 swap2
dup2: [] ap20 dup . ap04 swap4 drop

swap2: [] swap pushr swap pushr pushl pull3 drop
swap3: [] swap pushr swap pushr swap pushr pushl pull4 drop
swap4: [] swap pushr swap pushr swap pushr swap pushr pushl pull5 drop

module control:

imports:
  module stack
  module logic

__ if then else
ifte: [] ap20 swap pushr [not!] [swap drop!] | . pull drop

__ ifte2: rot [swap drop 0 != !] [0 == !] | pushl pushl pushl popr swap drop cut

__ apply a quote underneath the top
dip11: swap pushr ap12 swap2 drop
dip12: swap pushr ap13 swap3 drop
dip13: swap pushr ap14 swap4 drop

dip21: swap pushr ap22 swap2 drop
dip22: swap pushr ap23 swap3 drop
dip23: swap pushr ap24 swap4 drop

dip31: swap pushr ap32 swap2 drop
dip32: swap pushr ap33 swap3 drop
dip33: swap pushr ap34 swap4 drop

__ a [f] -> fa
$: ap11 swap drop

__ a [f] -> a fa
peek: [dup] dip12 $

__ a [f] -> fa a
->: peek swap

__ a [f] [g] -> fa ga
fork: [->] dip22 $

__ a b [f] [g] -> fa gb
para: [dip11] dip32 $

__ a b [f] -> fa fb
twice: dup para

__ a [cond] [f] -> fa
__ f fails if cond does not return True
if: [peek] dip22 swap [$] dip21 !

__ a [f b] -> fa if b, otherwise a
ifdo: dup [dup] swap . [[drop] dip21 not] . | ap12 swap2 drop !

__ a b -> a b [a b]
in2: [] ap20 dup [ap02 swap2 drop] dip12

__ a [fn] [test] -> apply fn to a while a [test] $ is True
iterate:
  in2 [iterate] .  __ a [fn] [test] [[fn] [test] iterate]
    [swap] dip22 . swap __ a [fn [fn] [test] iterate] [test]
    [fork] ap20 ifdo

__ initial step test base -> result
binrec: [iterate] dip31 $

module logic:

or: [not!] [True swap!] | ap21 swap drop
and: [!] [False swap not!] | ap21 swap drop

module algorithm:

imports:
  module stack
  module list
  module control

gcd:
  [] ap20 __ quote arguments [a b]
    [[tuck %] .] __ step: [a b] -> [b (a % b)]
    [head 0 !=] __ while: b != 0
    [popr drop head] __ return: a
    binrec
