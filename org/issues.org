#+TITLE: PoprC Issues

* STARTED Compile to C
Compile to direct C when possible
- strict, function arguments, no backtracking
** simple numeric ops (e.g. :c f1 + *)
* improvements
** DONE add afl fuzzing
** add more tests to tests.peg
** CANCELED clear_flags in func_select?
** DONE remove unnecessary clear_ptr's
*** mark_ptr
**** closure_set_ready
**** split_args
* major
** STARTED map assertions over lists to avoid unnecessary pushl-assert-popr
** DONE add reference checking assert to help find leaks (mini-valgrind)
** STARTED add support to return quoted functions from compiled functions
*** DONE count inputs
- all vars + open args on left
*** DONE store func_exec with entry + args + outputs
*** DONE compile auxilary functions
*** DONE handle pushl
- :d f1 1 swap pushl popr swap drop
- pushl before argument
- delay until lazy argument is evaluated?
  - just force both args when list is a var
** CANCELED compile all quoted functions
- part of "add support to return quoted functions from compiled functions"
** C generation
*** DONE Return types
*** DONE function signature
*** DONE simple expressions
*** DONE select -> if/then
*** STARTED pushl/popr
- experiments/quote
** modules
*** TODO module linking
*** DONE look up words from modules
*** DONE build/compile on demand
*** DONE add module union operation
** TODO look into adding conflict-driven clause learning
** DONE add comment and symbol support to parser
** DONE add primitive apNM operator
** CANCELED need a separate arity pass for placeholders?
* minor
** DONE memory leak in tests.pushl2
** DONE stable references in modules
** TODO handle module scope chain when compiling a word
look for word in parent module, parent imports, context module, context imports, ...
** TODO get cgen working with simple popr & pushl functions
** STARTED fix func_exec to work when branching and recursive
** DONE add compilation tests
** DONE handle alts correctly in func_exec
** DONE f1: [1+]
** DONE fix get2 in tests.peg
** TODO pass T_BOTTOM instead of T_ANY down reduce
** DONE remove cut
** TODO update refcnt for cells in genc
** TODO use refcounts properly for maps and lists in modules
** TODO add static asserts as tests
- check symbol table
- check builtins table order
** DONE adapt func_exec to new bytecode format
** DONE handle ENTRY_NOINLINE in func_exec
** DONE annotate trace with types in byte_compile.c
** DONE replace all tables with maps
** DONE add string map
* bugs
** TODO [1 2] [] | ? [id] [4] | . .
** DONE [ id 2 ] ? [ id ] . .
** DONE ? [ id ] [ id ] | .
eval: test.c:206: void assert_ref(cell_t ***, size_t): Assertion `check' failed.
** DONE [ id 2 2 ] ? [ id ] . .
eval: rt.c:804: cell_t *mutate(cell_t **, cell_t **, int): Assertion `check_deps(r)' failed.
** TODO [] ? dup [id] swap | . [] .
eval: rt.c:856: void clean_tmp(cell_t *): Assertion `~l->n' failed.
** TODO VV L JsC ! Js ! [ - ] ? | [ ] ? | [ * ! . . . * . * . Q [ G * ] dup - ] ? | [ ] ? | [ * ! . . . * . * ] . . popr
eval: rt.c:723: cell_t *add_to_list(cell_t *, cell_t *, cell_t **): Assertion `check_tmp_loop(*l)' failed.
** TODO [ 3 2 - ] > , [ 2 C - ] ? | .
eval: cells.c:263: csize_t closure_in(const cell_t *): Assertion `is_closure(c) && !is_value(c)' failed.
** TODO ? dup [+] . .
** TODO ? dup [+] . swap .
** TODO [ swap ] dup pushl popr drop dup pushl popr
Assertion failed: (check), function assert_ref, file test.c, line 205.
** DONE [ 3 ] ? [ ! ] . [ ] | . __ hang
** TODO f: . popr swap drop
** TODO f: pushr popr swap drop __ unreferenced pushr
** TODO fix tests.sum
** DONE f1: [1] swap ! popr swap drop
** TODO f1: 1 swap pushl popr ! popr swap drop
** TODO ? [dup 1- swap 3 <] [dup 1+ swap 3 >] | pushl popr ! popr swap drop
** DONE 1 2 3 | | dup 3 < !
** DONE f1: [ 1 ] [ 2 ] | pushl popr __ 3 f1
** TODO f1: [] pushl f1 __ why is arity 1 -> 2 instead of 1 -> 1?
** DONE f1: [] pushl
** TODO f1: dup f1 [] pushl
** DONE f2: popr swap pushl popr (regression)
** DONE :d f1 |
** DONE fix compiling pushr & pushl
- f1 pushr
- f2 popr swap pushl popr
- f3 swap pushl
** CANCELED select seems broken
:c f2 | popr ! cut popr swap drop
:c rot [] pushl swap pushr pushl popr swap popr swap popr swap drop
:c f5 [] pushl rot rot | swap pushl popr swap popr swap drop dup rot > ! cut
** DONE :c f2 pushl pushl popr 1 + swap pushl popr swap popr swap drop +
x y [z+] should be x + y + z + 1, gives 2y + 2z + 1
** TODO :c f1 [] [] ifte pushl
** STARTED :c loop dup 5 > [5- loop] [] ifte ap11 swap drop
- self/exec arity mismatch
** DONE smaller CELLS_SIZE breaks at module_lookup test
** DONE FIX: 0 [True =:=] [0 ==] | pushl popr swap drop
- returns {} instead of True
- works when alts are swapped
- args are failed on type mismatch, so it sticks for later alts
  - use something like split_args
** DONE :( -> segmentation fault
also just (
** DONE cut memory leak
1 2 | cut
** DONE :c c1 [ 1 ] swap . popr swap drop
** DONE :c f1 swap !
** DONE 100000 mod5 -> stack overflow (func_exec, func_select)
- treat select with variable arg as alt followed by cut
** DONE preserve select when using exec e.g. ifte
** DONE :c f1 pushl popr swap pushl popr
- [dup] popr swap pushl popr __ crash!
- [dup] popr swap pushl __ self referential dup
** DONE func_placeholder breaks when swapping popr eval order
:c p2 popr swap popr swap drop swap
* byte_compile
** DONE exec
** DONE replace func_self when loading code in func_exec
** DONE compose?
- in compose_nd
- fix compose_placeholders/_nd
** CANCELED build incomplete closures
- part of "add support to return quoted functions from compiled functions"
