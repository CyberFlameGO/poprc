module tests:

imports:
  module list

f2b: | popr ! cut popr swap drop

f5: [] pushl rot rot | swap pushl popr swap popr swap drop dup rot > ! cut

__ x y [z+] should be x + y + z + 1, gives 2y + 2z + 1
f2: pushl pushl popr 1 + swap pushl popr swap popr swap drop +

f1: [] [] ifte pushl

f6: rot

__ this expands forever because laziness expands backwards; assert must be *later* than recursive call
__ dec: [dup 5 <= !] [dup 5 > ! 1- dec] | pushl popr swap drop
dec: [dup 5 <= !] [dup 1- dec swap 5 > !] | pushl popr swap drop

fib: [dup 1 <= !] [dup 1- dup 1- fib swap fib + swap 1 > !] | pushl popr swap drop

fact: [1 == 1 swap !] [dup dup 1- fact * swap 1 > !] | pushl popr swap drop

___ these need fixed
___ from here

fact2: [1 == 1 swap !] [dup 1- swap [*] pushl swap pushr pushl get2 fact2] | pushl pushl get2
get2: popr swap popr swap drop swap

___ to here

not: False =:=
len: dup is_nil [0 swap!] [swap popr drop len 1+ swap not!] | pushl pushl popr swap drop

iota: [0 == [] swap !] [dup [dup 1- iota swap] pushl swap 0 != !] | pushl popr swap drop
