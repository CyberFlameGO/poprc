module tests:

imports:
  module list
  module stack
  module control

__ f2b: | popr ! cut popr swap drop

__ f5: [] pushl swap2 swap2 | swap pushl popr swap popr swap drop dup swap2 > ! cut

__ x y [z+] should be x + y + z + 1
f2: pushl pushl popr 1 + swap pushl popr swap popr swap drop +

__ f1: [] [] ifte pushl

f6: swap2

__ apply a quote to a single input yielding a single output
test_ap11: pushl popr swap drop

__ apply a quote to two inputs yielding a single output
test_ap21: pushl pushl popr swap drop

__ apply a quote to a single input yielding two outputs
test_ap12: pushl popr swap popr swap drop swap

__ this expands forever because laziness expands backwards; assert must be *later* than recursive call
__ dec: [dup 5 <= !] [dup 5 > ! 1- dec] | pushl popr swap drop
dec: [dup 5 <= !] [dup 1- dec swap 5 > !] | pushl popr swap drop

fib: [dup 1 <= !] [dup 1- dup 1- fib swap fib + swap 1 > !] | pushl popr swap drop

fact: [1 == 1 swap !] [dup dup 1- fact * swap 1 > !] | pushl popr swap drop

count: [0 == 0 swap !] [dup 1- count 1+ swap 0 > !] | pushl popr swap drop

qdec: [dup head 5 <= !] [dup [1-] . qdec swap head 5 > !] | pushl popr swap drop

qtest: [1+] . qtest
__ qtest2: [1+] swap . qtest2

___ these need fixed
___ from here

__ fact2: [1 == 1 swap !] [dup 1- swap [*] pushl swap pushr pushl get2 fact2] | pushl pushl get2
get2: popr swap popr swap drop swap

___ to here

__ len: dup is_nil [0 swap!] [swap popr drop len 1+ swap not!] | pushl pushl popr swap drop

__ iota: [0 == [] swap !] [dup [dup 1- iota swap] pushl swap 0 != !] | pushl popr swap drop
__ sum: [is_nil 0 swap !] [dup get2 swap sum + swap is_nil not!] | pushl popr swap drop

pushl2: pushl pushl

__[
range: __ with inputs i and n __
  __ return i or recursive call with i+1 __
  dup2 [drop] [swap 1+ swap range] | pushl2
    -swap2 <= ! __ make sure i <= n
    head __ get the value
]__

__[
nested: [[0 swap False =:= !]
           [1 swap True  =:= !] | swap False =:= !]
          [[2 swap False =:= !]
           [3 swap True  =:= !] | swap True  =:= !] |
           pushl popr swap drop __ first arg
           pushl popr swap drop __ second arg
]__

inl_loop: [3+] [10<] iterate
inl_loop2: swap [+] pushl swap [<] pushl iterate
inl_loop3: [3+] [10<] iterate 8*
inl_loop4: 4+ [3+] [10<] iterate 2*

popr_quote_compose: [popr] .
id_quote_compose: [id] .

__ test, should return x2
compose_alt: [1+] [] | . popr swap drop

__ initial step test base -> result
binrec: [iterate] dip31 $

__ it10 should optimize to the same code as br10
it10: [] pushl [[1+] .] [head 10 <] iterate head
br10: [] pushl [[1+] .] [head 10 <] [head] binrec
it10b: [[1+] .] [head 10 <] iterate head

ap_loop: dup [$] dip21 ap_loop
ap_loop1: [1+] ap_loop
ap_loop2: [[1+] .] ap_loop

__ ERROR: user_func.c:160: bind_pattern: Assertion `0' failed: binding error
__ ap_loop3: [] pushl [] ap_loop head

__ dup_ap_alt: [2 |] dup 1 swap $

__ a needlessly expensive `drop`
drop_loop:
  [] ap20
    [[1-] .]
    [head 0 >]
    iterate popd head

drop_loop1:
  [] ap10
    [[1-] .]
    [head 0 >]
    iterate head

__ ERROR: byte_compile.c:207: condense: Assertion `trace_decode(*p) > 0' failed.
__ drop_loop2:
__   [] ap20
__     [[1-] .]
__     [head 0 >]
__     iterate

drop_loop3:
  [] ap30
    [[1-] .]
    [head 0 >]
    iterate popd pull2 drop swap

drop_loop4:
  [] ap40
    [[1-] .]
    [head 0 >]
    iterate popd pull3 drop

__ ERROR byte_compile.c:207: condense: Assertion `trace_decode(*p) > 0' failed.
__ drop_loop_q: [] ap20 [[1-] .] [head 0 >] iterate

__ rec_a: rec_b 1 +
__ rec_b: rec_a 1 -

__ using floats
pct: ->f 100 /f 1 +f *f
